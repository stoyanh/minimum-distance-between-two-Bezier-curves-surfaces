<html>

<head>

</head>

<body>
    <input id="myInput" type="file" style="visibility:hidden" />
    <script src="js/three.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/BezierCurve.js"></script>
    <script src="js/Basis2D.js"></script>
    <script src="js/Grid2D.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/gjk.js"></script>
    <script src="js/main_algorithm.js"></script>    

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xEEEEEE);
        document.body.appendChild(renderer.domElement);
        camera.position.set(15, 15, 15);

        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2;
        window.addEventListener('resize', onWindowResize);

        let showControlPoints = false;
        let curves_points = [];
        //curve color, points color
        let colors = [[0xff0000, 0xff00aa], [0x32CD32, 0x0000FF]];
        let colors2 = {
            "green": 0x2AEF45,
            "red": 0xEE2E35,
            "blue": 0x3B2EEE,
            "yellow": 0xCCFF33,
            "purple": 0xFF33F9
        };

        let directions1 = [];

        let basis1 = {};
        let basis2 = {};

        let grid1 = {};
        let grid2 = {};

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function clear_scene() {
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
        }

        function render_scene() {
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render_scene();
        }

        function calc_min_dist() {
            if (curves_points.length < 2) {
                alert("There must be at least 2 curves!");
                return;
            }

            const min_dist = min_dist_algorithm(curves_points[0], curves_points[1], Number.MAX_SAFE_INTEGER);
            add_distance(scene, [min_dist["point1"], min_dist["point2"]]);
        }

        function validate_single_curve(curve) {
            if (curve.length < 3) {
                throw "how to handle lines";
            }

            var plane = new THREE.Plane().setFromCoplanarPoints(curve[0], curve[1], curve[curve.length - 1])
            if (plane.normal.equals(new THREE.Vector3(0, 0, 0))) {
                alert("Not coplanar points");
            }

            for (let i = 2; i < curve.length - 1; ++i) {
                if (plane.distanceToPoint(curve[i]) != 0) {
                    alert("Points are not coplanar");
                }
            }
        }

        function validate_plane_curves() {
            if (curves_points.length < 2) {
                alert("There must be at least 2 curves!");
                return;
            }
            validate_single_curve(curves_points[0])
            validate_single_curve(curves_points[1])
        }

        function create_2d_basis(curve) {
            let A = curve[0]
            let B = curve[1]
            let C = curve[curve.length - 1]

            let AB = B.clone().sub(A).normalize()
            let AC = C.clone().sub(A).normalize()

            var normal = AB.clone().cross(AC).normalize()
            var xAxis = AB.clone()
            var yAxis = normal.clone().cross(xAxis).normalize()

            var origin = A.clone()
            return new Basis2D(origin, xAxis, yAxis)
        }

        function setup_transformation_matrices() {
            basis1 = create_2d_basis(curves_points[0])
            basis2 = create_2d_basis(curves_points[1])
        }

        function calculateDirection(prevPoint, currPoint) {
            const dx = currPoint.x - prevPoint.x;
            const dy = currPoint.y - prevPoint.y;
            
            // Determine the direction based on the vector components
            let angle = Math.atan2(dy, dx); // Angle in radians
            
            // Convert the angle to degrees
            angle = THREE.MathUtils.radToDeg(angle);
            
            // Ensure the angle is positive and map it to the range [0, 360)
            if (angle < 0) {
                angle += 360;
            }
            
            // Map the angle to the corresponding Freeman chain code direction
            const direction = Math.round(angle / 45) % 8;
            
            return direction;
        }

        function generateChainCode(curve_points, basis, grid) {
            const chainCode = [];

            let curve = new BezierCurve(curve_points);

            // Traverse the curve and find the grid nodes closest to the curve intersections
            let points = curve.getPoints(5000);
            for (let i = 0; i < points.length; ++i) {
                const point = basis.convertTo2D(points[i]);

                //add_point(scene, points[i], colors2.green, 1.5);
          
                // Find the closest grid node to the current point
                let closestNode = -1;
                let found = false;

                let jStart = Math.floor(point.x / grid.gridDensity);
                let kStart = Math.floor(point.y / grid.gridDensity);

                for (let j = jStart; j <= jStart + 1; j++) {
                    for (let k = kStart; k <= kStart + 1; ++k) {
                        const node = grid.grid[j][k];
                        const distance = point.distanceTo(node);
                        if (Math.abs(distance) <= grid.gridDensity / 2)  {
                            closestNode = {j, k};
                            found = true;
                            break;
                        };
                    }
                    if (found) {
                        break;
                    }
                }

                if (!found) {
                    continue;
                }
                // Calculate the direction from the current point to the closest node
                let currNode = grid.grid[closestNode.j][closestNode.k];
                if (chainCode.length > 0) {
                    if (!currNode.equals(chainCode[chainCode.length - 1].node)) {
                        const direction = calculateDirection(chainCode[chainCode.length - 1].node, currNode);
                        // Add the direction to the chain code
                        chainCode.push({"node": currNode, "dir" : direction});
                    }
                }
                else {
                    chainCode.push({"node": currNode, "dir": -1});
                }
            }
            
            return chainCode;
        }


        function create_grid(curve_points, basis) {
            let maxX = 0;
            let maxY = 0;
            let minX = 0;
            let minY = 0;
            let curve = new BezierCurve(curve_points);
            let points = curve.getPoints(500);
            for (let i = 0; i < points.length; ++i) {
                let point = basis.convertTo2D(points[i]);
               if (!(point. x >= 0 && point.y >= 0)) {
                alert(
                    "Ne e dobre"
                )
               }
               if (point.x > maxX) {
                maxX = point.x;
               }
               if (point.y > maxY) {
                maxY = point.y;
               }
            }

           return new Grid2d(maxX, maxY);
        }

        function create_grids() {
            grid1 = create_grid(curves_points[0], basis1);
            grid2 = create_grid(curves_points[1], basis2);
        }

        function drawGrid(grid, basis, color=colors2.red) {
             for (let i = 0; i < grid.grid.length; ++i) {
                for (let j = 0; j < grid.grid[i].length; ++j) {
                    add_point(scene,  basis.convertTo3D(grid.grid[i][j]), color, 2.5);
                    // if (j < grid.grid[i].length - 1) {
                    //     let midPoint = grid.grid[i][j].clone().add(grid.grid[i][j + 1]).multiplyScalar(1 / 2);
                    //     add_point(scene, basis1.convertTo3D(midPoint), colors[1][1], 1);
                    // }
                }
            }
        }

        function drawChainCode(chainCode, grid, basis) {
            if (chainCode.length > 1) {
                for (let i = 2; i <= chainCode.length; ++i) {
                    let density = grid.gridDensity;
                    let diagonalDensity = Math.sqrt(2 * density * density)
                    let point1 = basis.convertTo3D(chainCode[i - 2].node);
                    let point2 = basis.convertTo3D(chainCode[i - 1].node);
                    let distance = point1.distanceTo(point2);
                    if (Math.abs(distance - density) > 0.1 && Math.abs(distance - diagonalDensity) > 0.1) {
                        let a = 0
                        a += 1
                    }
                    add_distance(scene, [point1, point2]);
                }       
            }
        }

        function algorithm() {
            let chainCode1 = generateChainCode(curves_points[0], basis1, grid1);
            drawChainCode(chainCode1, grid1, basis1);

            let x = {"min": 0, "max": 0};
            let y = {"min": 0, "max": 0};
            for (let i = 0; i < chainCode1.length; ++i) {
                if (chainCode1[i].node.x < chainCode1[x.min].node.x) {
                    x.min = i;
                }
                if (chainCode1[i].node.y < chainCode1[y.min].node.y) {
                    y.min = i;
                }
                if (chainCode1[i].node.x > chainCode1[x.max].node.x) {
                    x.max = i;
                }
                if (chainCode1[i].node.y > chainCode1[y.max].node.y) {
                    y.max = i;
                }
            }

            let tl = basis1.convertTo3D(new THREE.Vector3(chainCode1[x.min].node.x, chainCode1[y.min].node.y, 0));
            let tr = basis1.convertTo3D(new THREE.Vector3(chainCode1[x.max].node.x, chainCode1[y.min].node.y, 0));
            let bl = basis1.convertTo3D(new THREE.Vector3(chainCode1[x.min].node.x, chainCode1[y.max].node.y, 0));
            let br = basis1.convertTo3D(new THREE.Vector3(chainCode1[x.max].node.x, chainCode1[y.max].node.y, 0));

            add_distance(scene, [tl, tr], colors2.purple);
            add_distance(scene, [tr, br], colors2.purple);
            add_distance(scene, [br, bl], colors2.purple);
            add_distance(scene, [bl, tl], colors2.purple);

            let enclosing_points = [];

            const Axis = {
                none: -1,
                min_x: 0,
                min_y: 1,
                max_x: 2,
                max_y: 3
            };

            let last_on_axis = -1;
            let axis = Axis.none;
            function handle_idx(idx, current_axis) {
                if (axis != current_axis) {
                    if (axis != Axis.none && (enclosing_points.length < 1 || enclosing_points[enclosing_points.length - 1] != last_on_axis)) {
                        enclosing_points.push(last_on_axis);
                    }
                    enclosing_points.push(idx);
                }
                last_on_axis = idx;
                axis = current_axis;
            }
            for (let i = 0; i < chainCode1.length; ++i) {
                if (chainCode1[i].node.x == chainCode1[x.min].node.x) {
                    handle_idx(i, Axis.min_x);
                }
                else if (chainCode1[i].node.x == chainCode1[x.max].node.x) {
                    handle_idx(i, Axis.max_i);
                }
                else if (chainCode1[i].node.y == chainCode1[y.min].node.y) {
                    handle_idx(i, Axis.min_y);
                }
                else if (chainCode1[i].node.y == chainCode1[y.max].node.y) {
                    handle_idx(i, Axis.min_y);
                }
                // if (chainCode1[i].node.x == chainCode1[x.min].node.x || chainCode1[i].node.x == chainCode1[x.max].node.x) {
                //     if (chainCode1[i].dir != 2 && chainCode1[i].dir != 6) {
                //         enclosing_points.push(i);
                //         start = i;
                //     }
                // }
                // if (chainCode1[i].node.y == chainCode1[y.min].node.y || chainCode1[i].node.y == chainCode1[y.max].node.y) {
                //     if (chainCode1[i].dir != 0 && chainCode1[i].dir != 4 && enclosing_points[enclosing_points.length - 1] != i) {
                //         enclosing_points.push(i);
                //     }
                // }
            }
            if (enclosing_points[enclosing_points.length - 1] != last_on_axis) {
                enclosing_points.push(last_on_axis);
            }
            for (let i = 1; i < enclosing_points.length; ++i) {
                let start = basis1.convertTo3D(chainCode1[enclosing_points[i - 1]].node);
                let end = basis1.convertTo3D(chainCode1[enclosing_points[i]].node);
                add_distance(scene, [start, end], colors2.red);
            }
            add_distance(scene, 
            [basis1.convertTo3D(chainCode1[enclosing_points[enclosing_points.length - 1]].node), 
             basis1.convertTo3D(chainCode1[enclosing_points[0]])], colors2.red);
        }


        function update() {
            clear_scene();
            const axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );
            for (let i = 0; i < curves_points.length; ++i) {
                const bezier_curve = new BezierCurve(curves_points[i]);
                bezier_curve.addToScene(scene, showControlPoints, 
                colors[(i + 1) % colors.length][0], colors[(i + 1) % colors.length][1]);
            }
            validate_plane_curves()
            setup_transformation_matrices()
            create_grids();
            //drawGrid(grid1, basis1);
            //drawGrid(grid2, basis2, colors2.purple);
            algorithm();
            calc_min_dist();
            controls.update();
            render_scene();
        }

        //file loader
        const gui = new dat.GUI({ width: 310 });
        const params = {
            loadFile: function () {
                document.getElementById('myInput').click();
            },
            showControlPoints: false
        };
        gui.add(params, 'loadFile').name("Load file");
        gui.add(params, "showControlPoints").name("Show control points").listen().onChange(function(val) {
            showControlPoints = val;
            update();
        });

        const fileSelector = document.getElementById('myInput');
        fileSelector.onclick = function() {
            this.value = null;
        };
        fileSelector.addEventListener('change', (event) => {
            const fileList = event.target.files;
            let file = fileList[0];
            curves_points = [];
            parse_curves_file(file, curves_points, on_done => {
                update();

            });
        });

        const axesHelper = new THREE.AxesHelper( 5 );
        scene.add( axesHelper );
        animate();

    </script>
</body>

</html>