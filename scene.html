<html>

<head>

</head>

<body>
    <input id="curves_input" type="file" style="visibility:hidden" />
    <input id="surfaces_input" type="file" style="visibility:hidden" />
    <script src="js/three.js"></script>
    <script src="js/ParametricGeometry.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/BezierCurve.js"></script>
    <script src="js/BezierSurface.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/gjk.js"></script>
    <script src="js/main_algorithm.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xEEEEEE);
        document.body.appendChild(renderer.domElement);
        camera.position.set(15, 15, 15);

        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2;
        window.addEventListener('resize', onWindowResize);

        let showControlPointsCurves = false;
        let showControlPointsSurfaces = false;
        let curves_points = [];
        let surfaces_points = [];
        //curve color, points color
        let colors = [[0xff0000, 0xff00aa], [0x32CD32, 0x0000FF]];

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function clear_scene() {
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
        }

        function render_scene() {
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render_scene();
        }

        function calc_min_dist() {
            if (curves_points.length < 2) {
                alert("There must be at least 2 curves!");
                return;
            }

            const min_dist = min_dist_algorithm(curves_points[0], curves_points[1], Number.MAX_SAFE_INTEGER);
            add_distance(scene, [min_dist["point1"], min_dist["point2"]]);
        }

        function update() {
            clear_scene();
            const axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );
            for (let i = 0; i < curves_points.length; ++i) {
                const bezier_curve = new BezierCurve(curves_points[i]);
                bezier_curve.addToScene(scene, showControlPointsCurves, 
                colors[i % colors.length][0], colors[i % colors.length][1]);
            }
            calc_min_dist();
            controls.update();
            render_scene();
        }

        function update_surfaces() {
            clear_scene();
            const axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );
            for (let i = 0; i < surfaces_points.length; ++i) {
                const bezier_surface = new BezierSurface(surfaces_points[i]);
                bezier_surface.addToScene(scene, showControlPointsSurfaces, 
                colors[i % colors.length][0]);
            }

            if (surfaces_points.length < 2) {
                alert("There must be at least 2 curves!");
                return;
            }
            const sf_points1 = surfaces_points[0];
            const sf1_domain = {
                uMin: 0,
                uMax: 1,
                vMin: 0,
                vMax: 1
            };
            const sf_points2 = surfaces_points[1];
            const sf2_domain = {...sf1_domain};
            //let min_dist = gjk_min_dist(sf_points1.flat(), sf_points2.flat());
            const min_dist = min_dist_algorithm_surfaces(sf_points1, sf1_domain, sf_points2, sf2_domain, Number.MAX_SAFE_INTEGER);
            add_distance(scene, [min_dist["point1"], min_dist["point2"]]);
          
            controls.update();
            render_scene();
        }

        //file loader
        const gui = new dat.GUI({ width: 310 });

        // CURVES GUI
        const curves_params = {
            loadFile: function () {
                document.getElementById('curves_input').click();
            },
            showControlPoints: false
        };
        let curves_folder = gui.addFolder("Curves");
        curves_folder.open();
        curves_folder.add(curves_params, 'loadFile').name("Load file");
        curves_folder.add(curves_params, "showControlPoints").name("Show control points").listen().onChange(function(val) {
            showControlPointsCurves = val;
            update();
        });

        const fileSelector_curves = document.getElementById('curves_input');
        fileSelector_curves.onclick = function() {
            this.value = null;
        };
        fileSelector_curves.addEventListener('change', (event) => {
            const fileList = event.target.files;
            let file = fileList[0];
            curves_points = [];
            parse_curves_file(file, curves_points, on_done => {
                update();
            });
        });
        // CURVES GUI END

        // SURFACES GUI
        const surfaces_params = {
            loadFile: function () {
                document.getElementById('surfaces_input').click();
            },
            showControlPoints: false
        };
        let surfaces_folder = gui.addFolder("Surfaces");
        surfaces_folder.open();
        surfaces_folder.add(surfaces_params, 'loadFile').name("Load file");
        surfaces_folder.add(surfaces_params, "showControlPoints").name("Show control points").listen().onChange(function(val) {
            showControlPointsSurfaces = val;
            update_surfaces();
        });
        const fileSelector_surfaces = document.getElementById('surfaces_input');
        fileSelector_surfaces.onclick = function() {
            this.value = null;
        };
        fileSelector_surfaces.addEventListener('change', (event) => {
            const fileList = event.target.files;
            let file = fileList[0];
            surfaces_points = [];
            parse_surfaces_file(file, surfaces_points, on_done => {
                update_surfaces();
            });
        });

        // SURFACES GUI END

        const axesHelper = new THREE.AxesHelper( 5 );
        scene.add( axesHelper );
        animate();

    </script>
</body>

</html>